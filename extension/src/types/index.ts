/**
 * =============================================================================
 * CORTEX LATTICE - TYPE DEFINITIONS
 * =============================================================================
 *
 * This file defines all the TypeScript types used throughout the extension.
 * These types model the core domain objects for tracking coding practice:
 *
 * CORE CONCEPTS:
 * - Problem: A coding challenge from LeetCode or DesignGurus
 * - Attempt: One session of working on a problem (can have multiple per problem)
 * - Snapshot: A captured state of your code (taken on Run/Submit clicks)
 * - StuckPoint: When you get stuck and how you chose to proceed
 * - Reflection: Thoughts, "aha moments", or post-solve learnings
 * - SpacedRepetition: Scheduling data for when to review a problem again
 *
 * DATA FLOW:
 * User visits problem page → Problem created → Attempt started
 * User clicks Run/Submit → Snapshot captured
 * User gets stuck → StuckPoint recorded with intended action
 * User solves problem → Reflection captured → SpacedRepetition scheduled
 */

// =============================================================================
// ENUMS / LITERAL TYPES
// =============================================================================

/**
 * Supported coding platforms.
 * The extension scrapes different DOM elements based on the platform.
 */
export type Platform = 'leetcode' | 'grokking';

/**
 * Problem difficulty levels.
 * Used for display and potentially for adjusting spaced repetition intervals.
 */
export type Difficulty = 'easy' | 'medium' | 'hard';

/**
 * Current state of an attempt.
 * - in_progress: User is actively working on it
 * - completed: User finished (either passed or gave up)
 * - abandoned: User left without completing (auto-detected)
 */
export type AttemptStatus = 'in_progress' | 'completed' | 'abandoned';

/**
 * What triggered a code snapshot to be captured.
 * - run: User clicked "Run" to test against sample cases
 * - submit: User clicked "Submit" to test against all cases
 */
export type SnapshotTrigger = 'run' | 'submit';

/**
 * Result of running/submitting code.
 * - pass: All tests passed
 * - fail: Wrong answer or failed test cases
 * - error: Runtime error, compilation error, or timeout
 */
export type TestResult = 'pass' | 'fail' | 'error';

/**
 * What the user plans to do when they're stuck.
 * Used to track learning patterns and adjust spaced repetition.
 * - think_more: Keep trying independently (best for learning)
 * - check_hint: Look at a small hint (moderate help)
 * - ask_ai: Use AI assistance like ChatGPT (significant help)
 * - view_solution: Look at the answer (most help, shortest review interval)
 */
export type IntendedAction = 'think_more' | 'check_hint' | 'ask_ai' | 'view_solution';

/**
 * Types of reflections the user can log.
 * - thought: General observation or approach note
 * - aha: Breakthrough moment or insight
 * - stuck: Recording when/where they got stuck
 * - post_solve: Reflection after solving (what they learned)
 */
export type ReflectionType = 'thought' | 'aha' | 'stuck' | 'strategy' | 'post_solve';

/**
 * Self-assessed confidence after solving on first try.
 * Affects the initial spaced repetition interval.
 * - easy: "I could do this in my sleep" → longer interval (4 days)
 * - moderate: "Had to think but got it" → medium interval (3 days)
 * - lucky: "Not sure I could do it again" → short interval (1 day)
 */
export type Confidence = 'easy' | 'moderate' | 'lucky';

// =============================================================================
// DOMAIN OBJECTS
// =============================================================================

/**
 * Information about where a problem falls in the GTCI curriculum.
 * Used to group problems by algorithmic pattern for study tracking.
 */
export interface CurriculumInfo {
  /** Which curriculum track (currently only 'gtci' = Grokking the Coding Interview) */
  track: 'gtci';
  /** The algorithmic pattern (e.g., 'two-pointers', 'sliding-window', 'tree-bfs') */
  patternKey: string;
  /** Position within the pattern's problem sequence */
  index: number;
  /** Canonical normalizedTitle from the curriculum (for consistent DB lookups) */
  normalizedTitle?: string;
}

/**
 * A coding problem from a supported platform.
 * Created when user first visits a problem page.
 */
export interface Problem {
  /** Unique local ID (generated by extension) */
  id: string;
  /** Which platform this problem is from */
  platform: Platform;
  /** Full URL of the problem page */
  url: string;
  /** Problem title as displayed on the page */
  title: string;
  /** URL-friendly version of title for matching (lowercase, hyphenated) */
  normalizedTitle: string;
  /** Algorithmic pattern if matched to curriculum */
  pattern?: string;
  /** Difficulty level if detected from page */
  difficulty?: Difficulty;
  /** Curriculum placement if this is a GTCI problem */
  curriculum?: CurriculumInfo;
  /** When this problem was first encountered (Unix timestamp) */
  createdAt: number;
}

/**
 * One attempt at solving a problem.
 * A problem can have many attempts (e.g., initial solve, then reviews).
 * Each attempt tracks: when started, when ended, whether passed, how many tries.
 */
export interface Attempt {
  /** Unique local ID */
  id: string;
  /** ID of the problem being attempted */
  problemId: string;
  /** When the attempt started (Unix timestamp) */
  startedAt: number;
  /** When the attempt ended, if completed (Unix timestamp) */
  completedAt?: number;
  /** Current status of the attempt */
  status: AttemptStatus;
  /** Whether the user ultimately passed the problem */
  passed: boolean;
  /** Number of Run/Submit clicks during this attempt */
  snapshotCount: number;
}

/**
 * A captured state of the user's code.
 * Taken automatically when user clicks Run or Submit.
 * Enables tracking progression and identifying where users struggle.
 */
export interface Snapshot {
  /** Unique local ID */
  id: string;
  /** ID of the attempt this snapshot belongs to */
  attemptId: string;
  /** When the snapshot was taken (Unix timestamp) */
  timestamp: number;
  /** Whether this was a Run or Submit action */
  trigger: SnapshotTrigger;
  /** The actual code content at this moment */
  code: string;
  /** Result if detected (may be undefined if couldn't scrape result) */
  testResult?: TestResult;
}

/**
 * A recorded moment when the user got stuck.
 * Captures what they were stuck on and how they chose to proceed.
 * This data helps identify common sticking points and learning patterns.
 */
export interface StuckPoint {
  /** Unique local ID */
  id: string;
  /** ID of the attempt when user got stuck */
  attemptId: string;
  /** When this was recorded (Unix timestamp) */
  timestamp: number;
  /** User's description of what they're stuck on */
  description: string;
  /** What the user plans to do next */
  intendedAction: IntendedAction;
}

/**
 * A user reflection or note during problem-solving.
 * Can be thoughts during solving, breakthrough moments, or post-solve learnings.
 */
export interface Reflection {
  /** Unique local ID */
  id: string;
  /** ID of the attempt this reflection belongs to */
  attemptId: string;
  /** When this was recorded (Unix timestamp) */
  timestamp: number;
  /** What type of reflection this is */
  type: ReflectionType;
  /** The actual reflection content */
  content: string;
  /** Optional hint to show during next review (written by user after solving) */
  coldHint?: string;
  /** Self-assessed confidence (for post_solve reflections) */
  confidence?: Confidence;
}

/**
 * Spaced repetition data for a problem.
 * Tracks when to review and how well the user knows this problem.
 * Uses SM-2 algorithm variant with adjustments based on how problem was solved.
 */
export interface SpacedRepetition {
  /** ID of the problem (primary key - one SR record per problem) */
  problemId: string;
  /** When this problem should next be reviewed (Unix timestamp) */
  nextReview: number;
  /** Current interval in days (doubles on success, resets on failure) */
  intervalDays: number;
  /** SM-2 ease factor (higher = easier, starts at 2.5) */
  easeFactor: number;
  /** How many times this problem has been reviewed */
  reviewCount: number;
  /** When it was last reviewed (Unix timestamp) */
  lastReviewed?: number;
}

/**
 * Record of a completed review session.
 * Used for analytics and tracking review history.
 */
export interface ReviewResult {
  /** Unique local ID */
  id: string;
  /** ID of the problem that was reviewed */
  problemId: string;
  /** When the review was completed (Unix timestamp) */
  timestamp: number;
  /** Whether the user passed the review */
  passed: boolean;
  /** Whether it took multiple attempts to pass */
  wasMultiAttempt: boolean;
  /** What the interval was before this review */
  previousInterval: number;
  /** What the interval will be after this review */
  newInterval: number;
}

