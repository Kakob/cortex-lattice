/**
 * Auto-Linking Utilities
 *
 * Automatically creates links between contributions.
 * For example, links solutions to recent problems in the same session.
 */

import type { ContributionLinkType, InlineContribution } from "@/lib/types";

/**
 * Calculate similarity between two text strings.
 * Uses simple word overlap for MVP.
 */
function calculateTextSimilarity(text1: string, text2: string): number {
  const words1 = new Set(text1.toLowerCase().split(/\s+/).filter(w => w.length > 2));
  const words2 = new Set(text2.toLowerCase().split(/\s+/).filter(w => w.length > 2));

  if (words1.size === 0 || words2.size === 0) {
    return 0;
  }

  let overlap = 0;
  for (const word of words1) {
    if (words2.has(word)) {
      overlap++;
    }
  }

  // Jaccard similarity
  const union = new Set([...words1, ...words2]).size;
  return overlap / union;
}

/**
 * Determine if a solution should be auto-linked to a problem.
 */
export function shouldAutoLink(
  solution: { content: string; problemId: string; sessionId: string },
  problem: InlineContribution
): { shouldLink: boolean; confidence: number } {
  // Must be same problem and session
  if (solution.problemId !== problem.problemId || solution.sessionId !== problem.sessionId) {
    return { shouldLink: false, confidence: 0 };
  }

  // Must be a problem contribution
  if (problem.command !== "problem") {
    return { shouldLink: false, confidence: 0 };
  }

  // Calculate text similarity
  const textSimilarity = calculateTextSimilarity(solution.content, problem.content);

  // Base confidence from being in same session/problem
  let confidence = 0.5;

  // Boost confidence based on text similarity
  confidence += textSimilarity * 0.3;

  // Recency boost: problems created more recently are more likely related
  const problemAge = Date.now() - new Date(problem.timestamp).getTime();
  const recencyMinutes = problemAge / (1000 * 60);

  if (recencyMinutes < 5) {
    confidence += 0.2; // Very recent
  } else if (recencyMinutes < 15) {
    confidence += 0.1; // Recent
  }

  // Cap at 0.95 (never 100% confident for auto-generated)
  confidence = Math.min(0.95, confidence);

  // Threshold for auto-linking
  const shouldLink = confidence >= 0.5;

  return { shouldLink, confidence };
}

/**
 * Find recent problem contributions to potentially auto-link.
 */
export function findRecentProblems(
  contributions: InlineContribution[],
  sessionId: string,
  problemId: string,
  maxAgeMinutes: number = 30,
  limit: number = 5
): InlineContribution[] {
  const cutoffTime = Date.now() - maxAgeMinutes * 60 * 1000;

  return contributions
    .filter(c =>
      c.command === "problem" &&
      c.sessionId === sessionId &&
      c.problemId === problemId &&
      new Date(c.timestamp).getTime() > cutoffTime
    )
    .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
    .slice(0, limit);
}

/**
 * Generate auto-link candidates for a new solution.
 */
export function generateAutoLinkCandidates(
  solution: { content: string; problemId: string; sessionId: string },
  recentProblems: InlineContribution[]
): Array<{
  problemId: string;
  linkType: ContributionLinkType;
  confidence: number;
}> {
  const candidates: Array<{
    problemId: string;
    linkType: ContributionLinkType;
    confidence: number;
  }> = [];

  for (const problem of recentProblems) {
    const { shouldLink, confidence } = shouldAutoLink(solution, problem);

    if (shouldLink) {
      candidates.push({
        problemId: problem.id,
        linkType: "solves",
        confidence,
      });
    }
  }

  // Sort by confidence (highest first)
  return candidates.sort((a, b) => b.confidence - a.confidence);
}

/**
 * Create auto-links via API.
 */
export async function createAutoLinks(
  solutionId: string,
  candidates: Array<{
    problemId: string;
    linkType: ContributionLinkType;
    confidence: number;
  }>
): Promise<string[]> {
  const createdLinks: string[] = [];

  for (const candidate of candidates) {
    try {
      const response = await fetch("/api/contribution-links", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          fromContributionId: solutionId,
          toContributionId: candidate.problemId,
          linkType: candidate.linkType,
          autoGenerated: true,
          confidenceScore: candidate.confidence,
        }),
      });

      if (response.ok) {
        const link = await response.json();
        createdLinks.push(link.id);
      }
    } catch (error) {
      console.error("Failed to create auto-link:", error);
    }
  }

  return createdLinks;
}
