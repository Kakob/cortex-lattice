# dsa-study-log.yaml
# Keep this open while solving problems. Fill in as you go.

patterns:
  two-pointers:
    when_to_use: "sorted array, find pairs, move from both ends"
    template: |
      left, right = 0, len(arr)-1
      while left < right:
        # check condition, move pointers
    problems:
      - title: "Pair with Target Sum"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false
        
      - title: "Find Non-Duplicate Number Instances"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Squaring a Sorted Array"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Triplet Sum to Zero"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Triplet Sum Close to Target"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Triplets with Smaller Sum"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Dutch National Flag Problem"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Quadruple Sum to Target"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Comparing Strings containing Backspaces"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Window Sort"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  fast-slow-pointers:
    when_to_use: "cycle detection, find middle, linked lists"
    template: |
      slow = fast = head
      while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    problems:
      - title: "LinkedList Cycle"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Middle of the LinkedList"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Start of LinkedList Cycle"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Happy Number"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Palindrome LinkedList"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Rearrange a LinkedList"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Cycle in a Circular Array"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  sliding-window:
    when_to_use: "contiguous subarray/substring, fixed or variable size window"
    template: |
      window_start = 0
      for window_end in range(len(arr)):
        # add arr[window_end] to window
        while condition_to_shrink:
          # remove arr[window_start] from window
          window_start += 1
    problems:
      - title: "Maximum Sum Subarray of Size K"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Smallest Subarray With a Greater Sum"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Longest Substring with K Distinct Characters"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Fruits into Baskets"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Longest Substring with Same Letters after Replacement"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Longest Subarray with Ones after Replacement"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Permutation in a String"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "String Anagrams"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Smallest Window containing Substring"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Words Concatenation"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  merge-intervals:
    when_to_use: "overlapping intervals, scheduling, ranges"
    template: |
      intervals.sort(key=lambda x: x[0])
      merged = [intervals[0]]
      for interval in intervals[1:]:
        if interval[0] <= merged[-1][1]:
          merged[-1][1] = max(merged[-1][1], interval[1])
        else:
          merged.append(interval)
    problems:
      - title: "Merge Intervals"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Insert Interval"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Intervals Intersection"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Conflicting Appointments"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Meeting Rooms"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Maximum CPU Load"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Employee Free Time"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  cyclic-sort:
    when_to_use: "array with numbers 1 to n, find missing/duplicate"
    template: |
      i = 0
      while i < len(nums):
        correct_idx = nums[i] - 1
        if nums[i] != nums[correct_idx]:
          nums[i], nums[correct_idx] = nums[correct_idx], nums[i]
        else:
          i += 1
    problems:
      - title: "Cyclic Sort"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find the Missing Number"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find all Missing Numbers"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find the Duplicate Number"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find all Duplicate Numbers"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find the Corrupt Pair"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find the Smallest Missing Positive Number"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find the First K Missing Positive Numbers"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  linked-list-reversal:
    when_to_use: "reverse list or sublist in-place"
    template: |
      prev = None
      current = head
      while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
      return prev
    problems:
      - title: "Reverse a LinkedList"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Reverse a Sub-list"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Reverse every K-element Sub-list"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Reverse alternating K-element Sub-list"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Rotate a LinkedList"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  binary-search:
    when_to_use: "sorted/monotonic space, find boundary, largest/smallest where condition true"
    template: |
      left, right = 0, len(arr) - 1
      while left <= right:
        mid = left + (right - left) // 2
        if condition(mid):
          # adjust based on what you're finding
        else:
          # adjust other direction
    problems:
      - title: "Sqrt"
        difficulty: medium
        first_attempt: "linear scan checking consecutive squares"
        bugs: ["wrong parenthesis in mid calculation"]
        peeked_at: []
        key_insight: "squares are monotonic, binary search the answer space"
        can_solve_cold: false

      - title: "Order-agnostic Binary Search"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Ceiling of a Number"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Next Letter"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Number Range"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Search in a Sorted Infinite Array"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Difference Element"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Bitonic Array Maximum"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Search Bitonic Array"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Search in Rotated Array"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Rotation Count"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  tree-bfs:
    when_to_use: "level-by-level traversal, shortest path in unweighted tree"
    template: |
      from collections import deque
      queue = deque([root])
      while queue:
        level_size = len(queue)
        for _ in range(level_size):
          node = queue.popleft()
          # process node
          if node.left: queue.append(node.left)
          if node.right: queue.append(node.right)
    problems:
      - title: "Binary Tree Level Order Traversal"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Reverse Level Order Traversal"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Zigzag Traversal"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Level Averages in a Binary Tree"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Depth of a Binary Tree"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Level Order Successor"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Connect Level Order Siblings"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Connect All Level Order Siblings"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Right View of a Binary Tree"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  tree-dfs:
    when_to_use: "path problems, tree recursion, backtracking on trees"
    template: |
      def dfs(node, path):
        if not node: return
        path.append(node.val)
        if not node.left and not node.right:
          # leaf node - process path
        dfs(node.left, path)
        dfs(node.right, path)
        path.pop()  # backtrack
    problems:
      - title: "Binary Tree Path Sum"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "All Paths for a Sum"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Sum of Path Numbers"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Path With Given Sequence"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Count Paths for a Sum"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Tree Diameter"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Path with Maximum Sum"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  two-heaps:
    when_to_use: "find median, track smallest of large half + largest of small half"
    template: |
      import heapq
      max_heap = []  # smaller half (negate values)
      min_heap = []  # larger half
      # balance: len(max_heap) == len(min_heap) or len(max_heap) == len(min_heap) + 1
    problems:
      - title: "Find the Median of a Number Stream"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Sliding Window Median"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Maximize Capital"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Next Interval"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  subsets:
    when_to_use: "generate all combinations, permutations, power set"
    template: |
      result = [[]]
      for num in nums:
        result += [subset + [num] for subset in result]
      return result
    problems:
      - title: "Subsets"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Subsets With Duplicates"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Permutations"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "String Permutations by changing case"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Balanced Parentheses"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Unique Generalized Abbreviations"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Evaluate Expression"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Structurally Unique Binary Search Trees"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Count of Structurally Unique Binary Search Trees"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  top-k-elements:
    when_to_use: "find k largest/smallest, k most frequent"
    template: |
      import heapq
      # for k largest: use min heap of size k
      heap = []
      for num in nums:
        heapq.heappush(heap, num)
        if len(heap) > k:
          heapq.heappop(heap)
    problems:
      - title: "Top K Numbers"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Kth Smallest Number"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "K Closest Points to the Origin"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Connect Ropes"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Top K Frequent Numbers"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Frequency Sort"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Kth Largest Number in a Stream"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "K Closest Numbers"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Maximum Distinct Elements"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Sum of Elements"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Rearrange String"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Rearrange String K Distance Apart"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Scheduling Tasks"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Frequency Stack"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  k-way-merge:
    when_to_use: "merge k sorted lists, find kth element across sorted arrays"
    template: |
      import heapq
      heap = []
      for i, lst in enumerate(lists):
        if lst:
          heapq.heappush(heap, (lst[0], i, 0))
      while heap:
        val, list_idx, elem_idx = heapq.heappop(heap)
        # process val
        if elem_idx + 1 < len(lists[list_idx]):
          heapq.heappush(heap, (lists[list_idx][elem_idx+1], list_idx, elem_idx+1))
    problems:
      - title: "Merge K Sorted Lists"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Kth Smallest Number in M Sorted Lists"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Kth Smallest Number in a Sorted Matrix"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Smallest Number Range"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "K Pairs with Largest Sums"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  topological-sort:
    when_to_use: "ordering with dependencies, course schedule, build order"
    template: |
      from collections import deque, defaultdict
      in_degree = {node: 0 for node in nodes}
      graph = defaultdict(list)
      # build graph and in_degree
      queue = deque([n for n in nodes if in_degree[n] == 0])
      result = []
      while queue:
        node = queue.popleft()
        result.append(node)
        for neighbor in graph[node]:
          in_degree[neighbor] -= 1
          if in_degree[neighbor] == 0:
            queue.append(neighbor)
    problems:
      - title: "Topological Sort"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Tasks Scheduling"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Tasks Scheduling Order"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "All Tasks Scheduling Orders"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Alien Dictionary"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Reconstructing a Sequence"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Height Trees"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  dynamic-programming:
    when_to_use: "optimal substructure, overlapping subproblems, choices at each step"
    template: |
      # Usually: dp[i] = best answer considering first i elements
      # Recurrence: dp[i] = f(dp[i-1], dp[i-2], ...)
      # Base case: dp[0] = ...
    problems:
      - title: "0/1 Knapsack"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Equal Subset Sum Partition"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Subset Sum"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Subset Sum Difference"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Count of Subset Sum"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Target Sum"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Fibonacci numbers"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Staircase"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Number factors"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum jumps to reach the end"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum jumps with fee"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "House thief"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Longest Palindromic Subsequence"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Longest Palindromic Substring"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Count of Palindromic Substrings"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Deletions in a String to make it a Palindrome"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Palindromic Partitioning"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  graph-bfs-dfs:
    when_to_use: "traversal, connected components, shortest path (unweighted)"
    template: |
      # BFS
      from collections import deque
      visited = set()
      queue = deque([start])
      visited.add(start)
      while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
          if neighbor not in visited:
            visited.add(neighbor)
            queue.append(neighbor)
    problems:
      - title: "Find if Path Exists in Graph"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Number of Provinces"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Find Eventual Safe States"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Minimum Number of Vertices to Reach All Nodes"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Bus Routes"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  islands:
    when_to_use: "2D grid traversal, connected regions, flood fill"
    template: |
      def dfs(grid, r, c):
        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):
          return
        if grid[r][c] != '1':
          return
        grid[r][c] = '0'  # mark visited
        dfs(grid, r+1, c)
        dfs(grid, r-1, c)
        dfs(grid, r, c+1)
        dfs(grid, r, c-1)
    problems:
      - title: "Number of Islands"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Biggest Island"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Flood Fill"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Number of Closed Islands"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  backtracking:
    when_to_use: "explore all possibilities, undo choices, constraint satisfaction"
    template: |
      def backtrack(path, choices):
        if is_solution(path):
          result.append(path[:])
          return
        for choice in choices:
          if is_valid(choice):
            path.append(choice)
            backtrack(path, remaining_choices)
            path.pop()  # undo
    problems:
      - title: "Combination Sum"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Word Search"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Factor Combinations"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Split a String Into the Max Number of Unique Substrings"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Sudoku Solver"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  trie:
    when_to_use: "prefix matching, autocomplete, word dictionary"
    template: |
      class TrieNode:
        def __init__(self):
          self.children = {}
          self.is_end = False
      
      class Trie:
        def __init__(self):
          self.root = TrieNode()
        
        def insert(self, word):
          node = self.root
          for char in word:
            if char not in node.children:
              node.children[char] = TrieNode()
            node = node.children[char]
          node.is_end = True
    problems:
      - title: "Implement Trie (Prefix Tree)"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Index Pairs of a String"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Design Add and Search Words Data Structure"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Extra Characters in a String"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Search Suggestions System"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  union-find:
    when_to_use: "connected components, cycle detection, grouping"
    template: |
      class UnionFind:
        def __init__(self, n):
          self.parent = list(range(n))
          self.rank = [0] * n
        
        def find(self, x):
          if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
          return self.parent[x]
        
        def union(self, x, y):
          px, py = self.find(x), self.find(y)
          if px == py: return False
          if self.rank[px] < self.rank[py]:
            px, py = py, px
          self.parent[py] = px
          if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
          return True
    problems:
      - title: "Redundant Connection"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Number of Provinces"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Is Graph Bipartite?"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Path With Minimum Effort"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  monotonic-stack:
    when_to_use: "next greater/smaller element, histogram problems"
    template: |
      stack = []
      result = [-1] * len(nums)
      for i, num in enumerate(nums):
        while stack and nums[stack[-1]] < num:
          result[stack.pop()] = num
        stack.append(i)
    problems:
      - title: "Remove Nodes From Linked List"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Remove All Adjacent Duplicates In String"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Next Greater Element"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Daily Temperatures"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Remove All Adjacent Duplicates in String II"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Sum of Subarray Minimums"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Remove K Digits"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

  bitwise-xor:
    when_to_use: "find single number, pairs cancel out"
    template: |
      # x ^ x = 0
      # x ^ 0 = x
      result = 0
      for num in nums:
        result ^= num
    problems:
      - title: "Single Number"
        difficulty: easy
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Two Single Numbers"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Complement of Base 10 Number"
        difficulty: medium
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

      - title: "Flip and Invert an Image"
        difficulty: hard
        first_attempt: ""
        bugs: []
        peeked_at: []
        key_insight: ""
        can_solve_cold: false

# Track overall progress
progress:
  total_problems: 150
  solved_once: 0
  can_solve_cold: 0
  last_updated: ""
