/**
 * Contribution Links API
 *
 * POST /api/contribution-links - Create a link between contributions
 * GET /api/contribution-links - List links with filters
 */

import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/auth";
import prisma from "@/lib/db";
import type { ContributionLink, ContributionLinkType } from "@/lib/types";

interface CreateLinkInput {
  fromContributionId: string;
  toContributionId: string;
  linkType: ContributionLinkType;
  autoGenerated?: boolean;
  confidenceScore?: number;
}

/**
 * Create a link between two contributions.
 */
export async function POST(request: NextRequest) {
  try {
    // Check authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "Authentication required" },
        { status: 401 }
      );
    }

    const body: CreateLinkInput = await request.json();

    // Validate required fields
    if (!body.fromContributionId || !body.toContributionId || !body.linkType) {
      return NextResponse.json(
        { error: "Missing required fields: fromContributionId, toContributionId, linkType" },
        { status: 400 }
      );
    }

    // Validate link type
    const validLinkTypes = ["solves", "references", "extends"];
    if (!validLinkTypes.includes(body.linkType)) {
      return NextResponse.json(
        { error: `Invalid linkType: ${body.linkType}. Must be one of: ${validLinkTypes.join(", ")}` },
        { status: 400 }
      );
    }

    // Verify both contributions exist
    const [fromContribution, toContribution] = await Promise.all([
      prisma.inlineContribution.findUnique({ where: { id: body.fromContributionId } }),
      prisma.inlineContribution.findUnique({ where: { id: body.toContributionId } }),
    ]);

    if (!fromContribution) {
      return NextResponse.json(
        { error: `From contribution not found: ${body.fromContributionId}` },
        { status: 404 }
      );
    }

    if (!toContribution) {
      return NextResponse.json(
        { error: `To contribution not found: ${body.toContributionId}` },
        { status: 404 }
      );
    }

    // Create the link (upsert to handle duplicates)
    const link = await prisma.contributionLink.upsert({
      where: {
        fromContributionId_toContributionId_linkType: {
          fromContributionId: body.fromContributionId,
          toContributionId: body.toContributionId,
          linkType: body.linkType,
        },
      },
      update: {
        autoGenerated: body.autoGenerated ?? false,
        confidenceScore: body.confidenceScore,
      },
      create: {
        fromContributionId: body.fromContributionId,
        toContributionId: body.toContributionId,
        linkType: body.linkType,
        autoGenerated: body.autoGenerated ?? false,
        confidenceScore: body.confidenceScore,
      },
    });

    // Transform to API response format
    const response: ContributionLink = {
      id: link.id,
      fromContributionId: link.fromContributionId,
      toContributionId: link.toContributionId,
      linkType: link.linkType as ContributionLinkType,
      autoGenerated: link.autoGenerated,
      confidenceScore: link.confidenceScore ?? undefined,
      createdAt: link.createdAt.toISOString(),
    };

    return NextResponse.json(response, { status: 201 });
  } catch (error) {
    console.error("Failed to create contribution link:", error);
    return NextResponse.json(
      { error: "Failed to create contribution link" },
      { status: 500 }
    );
  }
}

/**
 * List contribution links with optional filters.
 */
export async function GET(request: NextRequest) {
  try {
    // Check authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "Authentication required" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const fromContributionId = searchParams.get("fromContributionId");
    const toContributionId = searchParams.get("toContributionId");
    const linkType = searchParams.get("linkType");
    const limit = parseInt(searchParams.get("limit") || "50", 10);
    const offset = parseInt(searchParams.get("offset") || "0", 10);

    // Build filter conditions
    const where: {
      fromContributionId?: string;
      toContributionId?: string;
      linkType?: string;
    } = {};

    if (fromContributionId) where.fromContributionId = fromContributionId;
    if (toContributionId) where.toContributionId = toContributionId;
    if (linkType) where.linkType = linkType;

    // Query links
    const links = await prisma.contributionLink.findMany({
      where,
      orderBy: { createdAt: "desc" },
      take: Math.min(limit, 100),
      skip: offset,
    });

    // Get total count for pagination
    const total = await prisma.contributionLink.count({ where });

    // Transform to API response format
    const items: ContributionLink[] = links.map((link) => ({
      id: link.id,
      fromContributionId: link.fromContributionId,
      toContributionId: link.toContributionId,
      linkType: link.linkType as ContributionLinkType,
      autoGenerated: link.autoGenerated,
      confidenceScore: link.confidenceScore ?? undefined,
      createdAt: link.createdAt.toISOString(),
    }));

    return NextResponse.json({
      items,
      total,
      limit,
      offset,
    });
  } catch (error) {
    console.error("Failed to list contribution links:", error);
    return NextResponse.json(
      { error: "Failed to list contribution links" },
      { status: 500 }
    );
  }
}
